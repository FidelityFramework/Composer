/// XDCTransfer — Parallel transfer from PlatformPinMapping coeffect to XDC text
///
/// Architecturally parallel to MLIRTransfer. Both observe the same coeffects:
///   - MLIRTransfer: coeffects → MLIR ops (via witness traversal)
///   - XDCTransfer:  coeffects → XDC text (pure function, no traversal needed)
///
/// The coeffect IS the pre-computed data. This transfer is serialization.
///
/// Output: Xilinx XDC constraints file for Vivado synthesis.
module Alex.Traversal.XDCTransfer

open PSGElaboration.Coeffects

/// Generate XDC constraint text from a PlatformPinMapping coeffect.
/// Pure function: PlatformPinMapping → string
let transfer (mapping: PlatformPinMapping) : string =
    let sb = System.Text.StringBuilder()

    // Header
    sb.AppendLine(sprintf "## XDC constraints for %s" mapping.DevicePart) |> ignore
    sb.AppendLine("## Generated by Composer from Fidelity.Platform pin definitions") |> ignore
    sb.AppendLine() |> ignore

    // Clock constraint
    let clk = mapping.Clock
    sb.AppendLine("# Clock") |> ignore
    sb.AppendLine(sprintf "set_property PACKAGE_PIN %s [get_ports {%s}]" clk.PackagePin clk.PortName) |> ignore
    sb.AppendLine(sprintf "set_property IOSTANDARD %s [get_ports {%s}]" clk.IOStandard clk.PortName) |> ignore
    let periodNs = 1_000_000_000.0 / (float clk.FrequencyHz)
    sb.AppendLine(sprintf "create_clock -add -name %s -period %.3f [get_ports {%s}]" clk.PortName periodNs clk.PortName) |> ignore
    sb.AppendLine() |> ignore

    // Group pins by direction
    let inputPins  = mapping.Pins |> List.filter (fun p -> p.Direction = "Input")
    let outputPins = mapping.Pins |> List.filter (fun p -> p.Direction = "Output")
    let inoutPins  = mapping.Pins |> List.filter (fun p -> p.Direction = "InOut")

    // Input constraints
    if not (List.isEmpty inputPins) then
        sb.AppendLine("# Inputs") |> ignore
        for pin in inputPins do
            sb.AppendLine(sprintf "set_property PACKAGE_PIN %s [get_ports {%s}]" pin.PackagePin pin.PortName) |> ignore
            sb.AppendLine(sprintf "set_property IOSTANDARD %s [get_ports {%s}]" pin.IOStandard pin.PortName) |> ignore
        sb.AppendLine() |> ignore

    // Output constraints
    if not (List.isEmpty outputPins) then
        sb.AppendLine("# Outputs") |> ignore
        for pin in outputPins do
            sb.AppendLine(sprintf "set_property PACKAGE_PIN %s [get_ports {%s}]" pin.PackagePin pin.PortName) |> ignore
            sb.AppendLine(sprintf "set_property IOSTANDARD %s [get_ports {%s}]" pin.IOStandard pin.PortName) |> ignore
        sb.AppendLine() |> ignore

    // InOut constraints
    if not (List.isEmpty inoutPins) then
        sb.AppendLine("# Bidirectional") |> ignore
        for pin in inoutPins do
            sb.AppendLine(sprintf "set_property PACKAGE_PIN %s [get_ports {%s}]" pin.PackagePin pin.PortName) |> ignore
            sb.AppendLine(sprintf "set_property IOSTANDARD %s [get_ports {%s}]" pin.IOStandard pin.PortName) |> ignore
        sb.AppendLine() |> ignore

    sb.ToString().TrimEnd()
